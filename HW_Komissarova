Метод принимает на вход обучающую и тестовую выборки, а также метки для обучающей выборки.
Идея метода: в обучающей выборке найти все импликации вида A→B, где A - некоторое подмножество атрибутов, B - метка объекта. В качестве подмножеств A рассматриваются intent-ы формальных понятий, поскольку нас интересует именно замыкание объектов по признакам. Иначе говоря, если фрукт оранжевый и круглый, то это апельсин, однако если фрукт просто круглый, то отсюда не следует, что это апельсин.
Шаги алгоритма:
1. построить решётку формальных понятий;
2. найти среди intent-ов нормальных понятий интересующие нас импликации вида A→B;
3. классифицировать объект из тестовой выборки на основе данного набора импликаций. Если классификация оказалась противоречивой (объекту были присвоены две метки), или же описание объекта не подошло ни к одной импликации, тогда ставим метку 'none'. Это адекватно, поскольку если мы не встречали объект, подходящий заданному описанию, то и классифицировать мы его не можем. Например, если в обучающей выборке мы классифицировали только цитрусовые, а в тестовой выборке встретили яблоко.
Недостатками алгоритма является высокая вычислительная сложность, поскольку приходится искать все формальные понятия, а также возможность того, что объект не будет классифицирован.
Первый недостаток можно решить, не рассматривая вложенные импликации, то есть если A→B, то нет смысла рассматривать AC→B. Второй недостаток можно решить, введя некоторые послабления для алгоритма классификации.
Программа написана на python 3.5.0, без подключаемых модулей. 
